<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î™®Îçò 2D ÌÉ±ÌÅ¨ Î†àÏù¥ÏÑú</title>
    <!-- Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            min-height: 100vh;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8);
            border-radius: 16px;
            overflow: hidden;
            background-color: #222;
            display: flex;
            flex-direction: column;
            border: 4px solid #444;
        }

        #gameCanvas {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background: linear-gradient(to bottom, #252525, #3a3a3a, #252525);
            box-shadow: inset 0 0 70px rgba(0, 0, 0, 0.7);
            touch-action: none;
            transform: perspective(700px) rotateX(2deg);
            transform-origin: bottom;
        }

        .lane-mark {
            position: absolute;
            /* Îçî Í∏∏Í≤å Î≥¥Ïù¥Îäî Ï∞®ÏÑ†: ÏúÑÏ™ΩÏùÄ ÏòÖÍ≥† ÏïÑÎûòÎ°ú Í∞àÏàòÎ°ù ÏßÑÌïòÍ≤å */
            background: linear-gradient(to bottom,
                rgba(241, 196, 15, 0.15),
                rgba(241, 196, 15, 0.9)
            );
            width: 10px;
            /* 70px ‚Üí 120px, Ï∞®ÏÑ† Í∏∏Ïù¥ Ï¶ùÍ∞Ä */
            height: 120px;
            opacity: 0.95;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(241, 196, 15, 1);
            z-index: 10;
        }

        /* ============== ÌÉ±ÌÅ¨ (ÌîåÎ†àÏù¥Ïñ¥) ============== */
        #player {
            position: absolute;
            width: 75px;  /* 6% Ï∂ïÏÜåÎêú ÌÅ¨Í∏∞ Í∏∞Ï§Ä */
            height: 75px;
            bottom: 100px;
            transition: left 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Îπ†Î•∏ Ïù¥Îèô */
            z-index: 50;
        }

        /* ÌÉ±ÌÅ¨ Î≥∏Ï≤¥ (ÏßôÏùÄ ÌöåÏÉâ) - ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÏ§ëÏïô Í∏∞Ï§Ä Ïû¨Ï°∞Ï†ï */
        .tank-body {
            position: absolute;
            width: 55px; /* 60px ‚Üí 55pxÎ°ú Ï§ÑÏó¨ Ï§ëÏã¨ Ï†ïÎ†¨ */
            height: 70px;
            left: 10px;  /* 0~75 Ï§ë 10~65 ‚Üí Ï§ëÏã¨ 37.5px */
            bottom: 10px;
            background: linear-gradient(to bottom, #7f8c8d, #5b6870);
            border: 3px solid #3d4a52;
            border-radius: 5px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.7);
        }

        .tank-tread-left, .tank-tread-right {
            position: absolute;
            width: 10px;
            height: 100%;
            background-color: #34495e;
            border-radius: 3px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .tank-tread-left { left: 0; }
        .tank-tread-right { right: 0; }

        .tank-turret {
            position: absolute;
            width: 50px;
            height: 35px;
            background: linear-gradient(45deg, #aeb6bf, #7f8c8d);
            border-radius: 3px;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            border: 2px solid #5b6870;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
            z-index: 60;
        }

        .tank-barrel {
            position: absolute;
            width: 15px;
            height: 40px;
            background: linear-gradient(to right, #7f8c8d, #95a5a6);
            border-radius: 3px 3px 0 0;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 55;
        }

        .shield-effect {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 94px;
            height: 94px;
            border-radius: 10px;
            background: rgba(155, 89, 182, 0.3);
            border: 3px solid #9b59b6;
            box-shadow: 0 0 20px #9b59b6;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 45;
        }

        .stunned {
            animation: flash 0.1s infinite alternate;
        }
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }

        .game-element {
            position: absolute;
            width: 55px;
            height: 55px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
            font-size: 28px;
            font-weight: 700;
            border-radius: 10px;
            z-index: 40;
            border: 3px solid;
            transition: transform 0.05s;
            background-color: transparent;
            backdrop-filter: blur(1px);
        }

        @keyframes wiggle {
            0%, 100% { transform: translateX(0) rotate(5deg); }
            50% { transform: translateX(3px) rotate(5deg); }
        }

        .bomb {
            border-color: #e74c3c;
            border-radius: 50%;
            font-size: 30px;
            color: #e74c3c;
        }
        .gift {
            border-color: #f39c12;
            border-radius: 8px;
            transform: rotate(5deg);
            animation: wiggle 0.5s ease-in-out infinite alternate;
            color: #f39c12;
        }
        .boost {
            border-color: #3498db;
            border-radius: 50%;
            font-size: 20px;
            color: #3498db;
        }
        .shield {
            border-color: #9b59b6;
            border-radius: 50%;
            font-size: 28px;
            color: #9b59b6;
        }
        .slow {
            border-color: #1abc9c;
            border-radius: 50%;
            font-size: 24px;
            color: #1abc9c;
        }

        .hud-top-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            pointer-events: none;
            z-index: 90;
        }

        .hud-item {
            padding: 6px 10px;
            border-radius: 6px;
            background-color: rgba(28, 40, 51, 0.85);
            color: #ecf0f1;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            margin: 0 4px;
            min-width: 70px;
            text-align: center;
            font-size: 12px;
            line-height: 1.2;
        }

        .hud-value {
            font-size: 16px;
            font-weight: 900;
            color: #f1c40f;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
            display: block;
        }

        .indicator-overlay {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 90;
        }

        .indicator {
            font-size: 12px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .overlay-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            pointer-events: none;
            z-index: 70;
        }

        .overlay-button {
            width: 100px;
            height: 70px;
            background-color: rgba(241, 196, 15, 0.1);
            border: 2px solid #f1c40f;
            color: #f1c40f;
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.05s, background-color 0.1s;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            border-radius: 12px;
        }

        .overlay-button:active {
            transform: scale(0.95);
            background-color: rgba(241, 196, 15, 0.3);
            text-shadow: 0 0 5px rgba(241, 196, 15, 1);
        }

        .message-box {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .message-content {
            background: #2c3e50;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.8), inset 0 0 10px #444;
            color: white;
            border: 2px solid #3498db;
        }
    </style>
</head>
<body>

<div class="game-container">
    <div id="gameCanvas">
        <!-- HUD -->
        <div id="hudOverlay" class="hud-top-overlay">
            <div class="flex-1 text-left">
                <div class="hud-item inline-block">
                    Ï†êÏàò: <span id="scoreDisplay" class="hud-value">0</span>
                </div>
                <div class="hud-item inline-block">
                    Í±∞Î¶¨: <span id="distanceDisplay" class="hud-value text-green-400">0 m</span>
                </div>
                <div class="hud-item inline-block">
                    ÏãúÍ∞Ñ: <span id="timeDisplay" class="hud-value text-blue-400">0.0 s</span>
                </div>
            </div>
            <div class="flex-1 text-right">
                <div class="hud-item inline-block">
                    ÏÜçÎèÑ: <span id="speedDisplay" class="hud-value">2.0 m/s</span>
                </div>
                <div class="hud-item inline-block">
                    Ìè≠ÌÉÑ: <span id="bombHitDisplay" class="hud-value text-red-400">0 / 3</span>
                </div>
            </div>
        </div>

        <!-- Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ -->
        <div class="indicator-overlay">
            <span id="boostIndicator" class="indicator text-blue-300 hidden">
                <i class="fas fa-bolt"></i> X2 ÌôúÏÑ±Ìôî (<span id="boostTimer">0.0</span>s)
            </span>
            <span id="shieldIndicator" class="indicator text-purple-300 hidden">
                <i class="fas fa-shield-alt"></i> Î∞©Ìå®: 1Ìöå
            </span>
        </div>

        <!-- ÌîåÎ†àÏù¥Ïñ¥ ÌÉ±ÌÅ¨ -->
        <div id="player">
            <div id="shieldEffect" class="shield-effect hidden"></div>
            <div class="tank-tread-left"></div>
            <div class="tank-tread-right"></div>
            <div class="tank-body"></div>
            <div class="tank-turret"></div>
            <div class="tank-barrel"></div>
        </div>

        <!-- ÏãúÏûë/Í≤åÏûÑÏò§Î≤Ñ Î©îÏãúÏßÄ -->
        <div id="messageBox" class="message-box" style="display: flex;">
            <div class="message-content">
                <h2 class="text-3xl font-bold mb-4 text-white">ÌÉ±ÌÅ¨ Î°úÎìú Î†àÏù¥ÏÑú (SC-T)</h2>
                <p class="mb-6 text-gray-300">ÌôîÎ©¥ Ïä§ÏôÄÏù¥ÌîÑ, Ï∞®ÏÑ† ÌÑ∞Ïπò, ÌïòÎã® Î≤ÑÌäºÏúºÎ°ú Ï∞®ÏÑ†ÏùÑ Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî!</p>
                <p class="mb-8 text-sm text-gray-400">Ìè≠ÌÉÑ 3Ìöå Ï∂©Îèå Ïãú Í≤åÏûÑ Ïò§Î≤Ñ</p>
                <button id="startButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 rounded-xl transition duration-150 shadow-lg">
                    <i class="fas fa-play"></i> Í≤åÏûÑ ÏãúÏûë (2m/s)
                </button>
            </div>
        </div>

        <!-- Ï°∞Ïûë Î≤ÑÌäº -->
        <div class="overlay-controls">
            <button id="leftButton" class="overlay-button">
                <i class="fas fa-arrow-left"></i>
            </button>
            <button id="rightButton" class="overlay-button">
                <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>
</div>

<script>
    // ============== ÏÉÅÏàò Î∞è Ï¥àÍ∏∞ ÏÑ§Ï†ï ==============
    const gameCanvas = document.getElementById('gameCanvas');
    const player = document.getElementById('player');
    const shieldEffect = document.getElementById('shieldEffect');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const distanceDisplay = document.getElementById('distanceDisplay');
    const speedDisplay = document.getElementById('speedDisplay');
    const bombHitDisplay = document.getElementById('bombHitDisplay');
    const messageBox = document.getElementById('messageBox');
    const startButton = document.getElementById('startButton');
    const boostIndicator = document.getElementById('boostIndicator');
    const boostTimer = document.getElementById('boostTimer');
    const shieldIndicator = document.getElementById('shieldIndicator');
    const leftButton = document.getElementById('leftButton');
    const rightButton = document.getElementById('rightButton');
    const timeDisplay = document.getElementById('timeDisplay');

    const LANE_WIDTH = 100;
    const INITIAL_SPEED = 2.0;
    const SPEED_INCREMENT_TIME = 8000;
    const SPEED_INCREMENT_AMOUNT = 0.5;

    const LANE_MARK_HEIGHT = 120;  // Ï∞®ÏÑ† Í∏∏Ïù¥ Ï¶ùÍ∞Ä
    const LANE_MARK_GAP = 60;    // Í∞ÑÍ≤©ÏùÑ Ï§ÑÏó¨ Í±∞Ïùò Ïù¥Ïñ¥ÏßÑ ÎäêÎÇå
    const LANE_MARK_CYCLE = LANE_MARK_HEIGHT + LANE_MARK_GAP;

    // Ìè≠ÌÉÑ/ÏïÑÏù¥ÌÖú Í∞ÑÍ≤©(5% Ï¶ùÍ∞Ä)
    const ITEM_MIN_GAP_DISTANCE = 157.5;

    const BOOST_DURATION = 4000;
    const BOMB_STUN_DURATION = 300;
    const BOMB_MAX_HITS = 3;

    const RARE_ITEM_COOLDOWN = 10000;
    const SLOW_ITEM_COOLDOWN = 30000; // 30Ï¥àÎßàÎã§ ÏÜçÎèÑ Í∞êÏÜå ÏïÑÏù¥ÌÖú

    const SWIPE_THRESHOLD = 50;

    // ============== Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÏàò ==============
    let isPlaying = false;
    let score = 0;
    let distance = 0;       // m
    let elapsedTime = 0;    // s
    let speed = INITIAL_SPEED;
    let bombHits = 0;
    let shieldCount = 0;
    let isStunned = false;

    // 1mÎãπ Ï†êÏàò Ï¶ùÍ∞Ä Í∏∞Ï§Ä
    let lastScoreDistance = 0;

    let touchStartX = 0;
    let lastTime = 0;

    let items = [];
    let laneMarks = [];

    let nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE * 1.5;

    let lastSpeedIncreaseTime = 0;
    let lastBoostTime = 0;
    let lastShieldTime = 0;
    let lastSlowTime = 0;

    const HIGH_SCORE_KEY = 'tankRacerHighScore';
    let bestScore = 0;
    try {
        const stored = localStorage.getItem(HIGH_SCORE_KEY);
        if (stored !== null) {
            const parsed = parseInt(stored, 10);
            if (!isNaN(parsed)) bestScore = parsed;
        }
    } catch (e) {
        bestScore = 0;
    }

    let gameFrame = null;

    let canvasWidth = 0;
    let canvasHeight = 0;
    let laneCenters = [0, 0, 0];
    let currentLane = 1; // Í∞ÄÏö¥Îç∞

    const playerWidth = 75;
    const playerHeight = 75;
    const itemSize = 55;
    const PLAYER_BOTTOM_OFFSET = 100;
    const DRAW_FACTOR = 150;

    // ============== Ï¥àÍ∏∞Ìôî Î∞è Î¶¨ÏÇ¨Ïù¥Ï¶à ==============
    function setupCanvas() {
        canvasWidth = gameCanvas.clientWidth;
        canvasHeight = gameCanvas.clientHeight;

        laneCenters[0] = canvasWidth / 2 - LANE_WIDTH;
        laneCenters[1] = canvasWidth / 2;
        laneCenters[2] = canvasWidth / 2 + LANE_WIDTH;

        resetPlayerPosition();
    }

    function resetPlayerPosition() {
        player.style.left = `${laneCenters[currentLane] - playerWidth / 2}px`;
        player.style.bottom = `${PLAYER_BOTTOM_OFFSET}px`;
    }

    // ============== Í≤åÏûÑ ÏÉÅÌÉú Í¥ÄÎ¶¨ ==============
    function startGame() {
        if (isPlaying) return;

        score = 0;
        distance = 0;
        elapsedTime = 0;
        lastScoreDistance = 0;
        speed = INITIAL_SPEED;
        bombHits = 0;
        shieldCount = 0;
        isStunned = false;
        currentLane = 1;

        // Í∏∞Ï°¥ ÏöîÏÜå Ï†úÍ±∞
        items.forEach(item => item.element.remove());
        items = [];
        laneMarks.forEach(mark => mark.element.remove());
        laneMarks = [];

        const now = performance.now();
        nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE * 1.5;

        lastTime = now;
        lastSpeedIncreaseTime = now;
        lastBoostTime = now - RARE_ITEM_COOLDOWN;   // ÏãúÏûëÎ∂ÄÌÑ∞ Î∂ÄÏä§Ìä∏/Î∞©Ìå® Ï∂úÌòÑ Í∞ÄÎä•
        lastShieldTime = now - RARE_ITEM_COOLDOWN;
        lastSlowTime = now;                          // Ï≤´ ÏÜçÎèÑ Í∞êÏÜå ÏïÑÏù¥ÌÖúÏùÄ 30Ï¥à ÌõÑÏØ§

        messageBox.style.display = 'none';
        player.classList.remove('stunned');
        updateShieldVisual();
        updateHUD();
        resetPlayerPosition();

        isPlaying = true;
        gameFrame = requestAnimationFrame(gameLoop);
    }

    function endGame() {
        if (!isPlaying) return;
        isPlaying = false;
        if (gameFrame) cancelAnimationFrame(gameFrame);

        let isNewRecord = false;
        if (score > bestScore) {
            isNewRecord = true;
            bestScore = score;
            try {
                localStorage.setItem(HIGH_SCORE_KEY, String(bestScore));
            } catch (e) {
                // localStorage ÏÇ¨Ïö© Î∂àÍ∞Ä ÌôòÍ≤ΩÏùÄ Î¨¥Ïãú
            }
        }

        messageBox.style.display = 'flex';

        const titleEl = document.querySelector('.message-content h2');
        if (isNewRecord) {
            titleEl.textContent = '!!ÏµúÍ≥† Ï†êÏàò!!';
        } else {
            titleEl.textContent = 'üí• Í≤åÏûÑ Ïò§Î≤Ñ! üí•';
        }

        document.querySelector('.message-content p').innerHTML =
            `ÏµúÏ¢Ö Ï†êÏàò: <span class="font-bold text-2xl text-yellow-500">${score} Ï†ê</span><br>` +
            `ÏµúÍ≥† Ï†êÏàò: <span class="font-bold text-2xl text-yellow-500">${bestScore} Ï†ê</span><br>` +
            `Ï£ºÌñâ Í±∞Î¶¨: <span class="font-bold text-2xl text-green-500">${distance.toFixed(0)} m</span><br>` +
            `ÏßÑÌñâ ÏãúÍ∞Ñ: <span class="font-bold text-2xl text-blue-400">${elapsedTime.toFixed(1)} s</span>`;
        startButton.innerHTML = '<i class="fas fa-redo"></i> Îã§Ïãú ÏãúÏûë';
    }

    function handleStun() {
        if (isStunned) return;
        isStunned = true;
        player.classList.add('stunned');
        setTimeout(() => {
            isStunned = false;
            player.classList.remove('stunned');
        }, BOMB_STUN_DURATION);
    }

    function updateShieldVisual() {
        shieldEffect.classList.toggle('hidden', shieldCount <= 0);
    }

    // ============== Ïù¥Îèô/ÏûÖÎ†• Ï≤òÎ¶¨ ==============
    function moveTank(direction) {
        if (!isPlaying || isStunned) return;
        const newLane = currentLane + direction;
        if (newLane >= 0 && newLane < 3) {
            currentLane = newLane;
            player.style.left = `${laneCenters[currentLane] - playerWidth / 2}px`;
        }
    }

    startButton.addEventListener('click', startGame);
    leftButton.addEventListener('click', () => moveTank(-1));
    rightButton.addEventListener('click', () => moveTank(1));

    document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
            moveTank(-1);
        } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
            moveTank(1);
        }
    });

    function handleStart(e) {
        if (!isPlaying) return;
        if (e.target.closest('.overlay-button')) return;
        e.preventDefault();
        touchStartX = e.touches ? e.touches[0].clientX : e.clientX;
    }

    function handleEnd(e) {
        if (!isPlaying) return;
        if (e.target.closest('.overlay-button')) return;

        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const deltaX = clientX - touchStartX;

        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
            // Ïä§ÏôÄÏù¥ÌîÑ
            if (deltaX > 0) moveTank(1);
            else moveTank(-1);
        } else {
            // Ï∞®ÏÑ† ÌÑ∞Ïπò: ÌôîÎ©¥ ÏôºÏ™Ω 1/3 ‚Üí ÏôºÏ™Ω, Ïò§Î•∏Ï™Ω 1/3 ‚Üí Ïò§Î•∏Ï™Ω
            const rect = gameCanvas.getBoundingClientRect();
            const xRelative = clientX - rect.left;

            if (xRelative < canvasWidth / 3) {
                moveTank(-1);
            } else if (xRelative > (canvasWidth * 2) / 3) {
                moveTank(1);
            }
        }
    }

    gameCanvas.addEventListener('touchstart', handleStart);
    gameCanvas.addEventListener('touchend', handleEnd);
    gameCanvas.addEventListener('mousedown', handleStart);
    gameCanvas.addEventListener('mouseup', handleEnd);

    window.addEventListener('resize', setupCanvas);
    window.addEventListener('load', setupCanvas);

    // ============== Ï∞®ÏÑ† ÎßàÌÅ¨ ==============
    function spawnLaneMarks(yPosition) {
        const markWidth = 10;
        const boundary1X = laneCenters[1] - LANE_WIDTH / 2 - markWidth / 2;
        const boundary2X = laneCenters[1] + LANE_WIDTH / 2 - markWidth / 2;

        [boundary1X, boundary2X].forEach(xPos => {
            const mark = document.createElement('div');
            mark.className = 'lane-mark';
            mark.style.left = `${xPos}px`;
            mark.style.top = `${yPosition}px`;
            gameCanvas.appendChild(mark);
            laneMarks.push({ element: mark, y: yPosition });
        });
    }

    function updateLaneMarks(deltaTime) {
        const moveDistance = speed * deltaTime * DRAW_FACTOR;

        for (let i = laneMarks.length - 1; i >= 0; i--) {
            const mark = laneMarks[i];
            mark.y += moveDistance;
            mark.element.style.top = `${mark.y}px`;
            if (mark.y > canvasHeight) {
                mark.element.remove();
                laneMarks.splice(i, 1);
            }
        }

        const topMark = laneMarks.length > 0
            ? laneMarks.reduce((a, b) => (a.y < b.y ? a : b))
            : null;

        if (!topMark || topMark.y >= -LANE_MARK_CYCLE) {
            const newY = topMark ? topMark.y - LANE_MARK_CYCLE : -LANE_MARK_HEIGHT;
            spawnLaneMarks(newY);
        }
    }

    // ============== ÏïÑÏù¥ÌÖú Ïä§Ìè∞/ÏóÖÎç∞Ïù¥Ìä∏ ==============
    function spawnItem() {
        const laneIndex = Math.floor(Math.random() * 3);
        const now = performance.now();

        const isBoostReady = now - lastBoostTime >= RARE_ITEM_COOLDOWN;
        const isShieldReady = now - lastShieldTime >= RARE_ITEM_COOLDOWN;
        const isSlowReady = now - lastSlowTime >= SLOW_ITEM_COOLDOWN;

        const itemPool = ['bomb', 'gift'];
        if (isBoostReady) itemPool.push('boost');
        if (isShieldReady) itemPool.push('shield');

        let itemType;
        const rand = Math.random();

        if (isSlowReady) {
            // 30Ï¥àÎßàÎã§ Ìïú Î≤àÏùÄ ÏÜçÎèÑ Í∞êÏÜå ÏïÑÏù¥ÌÖú
            itemType = 'slow';
            lastSlowTime = now;
        } else {
            // Ìè≠ÌÉÑ 45%, ÏÑ†Î¨º 45%, Î†àÏñ¥(Î∂ÄÏä§Ìä∏/Î∞©Ìå®) 10%
            if (rand < 0.45) {
                itemType = 'bomb';
            } else if (rand < 0.90) {
                itemType = 'gift';
            } else {
                const rareItems = itemPool.filter(i => i === 'boost' || i === 'shield');
                if (rareItems.length > 0) {
                    itemType = rareItems[Math.floor(Math.random() * rareItems.length)];
                } else {
                    itemType = Math.random() < 0.5 ? 'bomb' : 'gift';
                }
            }
        }

        // Î†àÏñ¥ ÏïÑÏù¥ÌÖú Ïø®Îã§Ïö¥ Í∞±Ïã†
        if (itemType === 'boost' && isBoostReady) {
            lastBoostTime = now;
        } else if (itemType === 'shield' && isShieldReady) {
            lastShieldTime = now;
        }

        const element = document.createElement('div');
        element.className = 'game-element ' + itemType;
        element.style.top = `${-itemSize}px`;
        element.style.left = `${laneCenters[laneIndex] - itemSize / 2}px`;
        element.dataset.type = itemType;

        switch (itemType) {
            case 'bomb':
                element.innerHTML = '<i class="fas fa-bomb"></i>';
                break;
            case 'gift':
                element.innerHTML = '<i class="fas fa-gift"></i>';
                break;
            case 'boost':
                element.innerHTML = 'X2';
                break;
            case 'shield':
                element.innerHTML = '<i class="fas fa-shield-alt"></i>';
                break;
            case 'slow':
                element.innerHTML = 'slow';
                break;
        }

        gameCanvas.appendChild(element);
        items.push({ element, y: -itemSize, laneIndex });
    }

    function updateItems(deltaTime) {
        const now = performance.now();
        const effectiveSpeed = isStunned ? 0 : speed;
        const moveDistance = effectiveSpeed * deltaTime * DRAW_FACTOR;

        nextItemSpawnDistance -= moveDistance;
        if (nextItemSpawnDistance <= 0) {
            spawnItem();
            nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE + Math.random() * 100;
        }

        const playerX = parseFloat(player.style.left) || (laneCenters[currentLane] - playerWidth / 2);
        const playerYTop = canvasHeight - playerHeight - PLAYER_BOTTOM_OFFSET;
        const playerYBottom = canvasHeight - PLAYER_BOTTOM_OFFSET;

        for (let i = items.length - 1; i >= 0; i--) {
            const item = items[i];
            item.y += moveDistance;
            item.element.style.top = `${item.y}px`;

            const itemX = parseFloat(item.element.style.left);

            const isColliding =
                item.y + itemSize > playerYTop &&
                item.y < playerYBottom &&
                itemX < playerX + playerWidth &&
                itemX + itemSize > playerX;

            if (isColliding) {
                handleCollision(item, now);
                item.element.remove();
                items.splice(i, 1);
            } else if (item.y > canvasHeight) {
                item.element.remove();
                items.splice(i, 1);
            }
        }
    }

    function handleCollision(item, now) {
        const itemType = item.element.dataset.type;
        const isBoostActive = now < lastBoostTime + BOOST_DURATION;

        switch (itemType) {
            case 'bomb':
                if (shieldCount > 0) {
                    shieldCount--;
                    updateShieldVisual();
                } else {
                    bombHits++;
                    handleStun();
                    if (bombHits >= BOMB_MAX_HITS) {
                        endGame();
                        return;
                    }
                }
                break;
            case 'gift':
                score += isBoostActive ? 20 : 10;
                break;
            case 'boost':
                lastBoostTime = now;
                break;
            case 'shield':
                shieldCount = 1;
                updateShieldVisual();
                break;
            case 'slow':
                speed = Math.max(0.5, speed - 0.3);
                break;
        }

        updateHUD();
    }

    // ============== HUD ==============
    function updateHUD() {
        const now = performance.now();
        const boostEndTime = lastBoostTime + BOOST_DURATION;
        const isBoostActive = now < boostEndTime;

        scoreDisplay.textContent = score;
        distanceDisplay.textContent = `${distance.toFixed(0)} m`;
        timeDisplay.textContent = `${elapsedTime.toFixed(1)} s`;
        speedDisplay.textContent = `${speed.toFixed(1)} m/s`;
        bombHitDisplay.textContent = `${bombHits} / ${BOMB_MAX_HITS}`;

        boostIndicator.classList.toggle('hidden', !isBoostActive);
        if (isBoostActive) {
            const remainingSeconds = Math.max(0, (boostEndTime - now) / 1000);
            boostTimer.textContent = remainingSeconds.toFixed(1);
        }

        shieldIndicator.classList.toggle('hidden', shieldCount <= 0);
    }

    // ============== Î©îÏù∏ Î£®ÌîÑ ==============
    function gameLoop(currentTime) {
        if (!isPlaying) return;

        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        elapsedTime += deltaTime;

        const effectiveSpeed = isStunned ? 0 : speed;
        distance += effectiveSpeed * deltaTime;

        // 1m ÏßÑÌñâ Ïãú 1Ï†êÏî© Ï¶ùÍ∞Ä
        const distanceInt = Math.floor(distance);
        if (distanceInt > lastScoreDistance) {
            score += distanceInt - lastScoreDistance;
            lastScoreDistance = distanceInt;
        }

        // ÏùºÏ†ï ÏãúÍ∞ÑÎßàÎã§ ÏÜçÎèÑ Ï¶ùÍ∞Ä
        if (currentTime - lastSpeedIncreaseTime >= SPEED_INCREMENT_TIME) {
            speed += SPEED_INCREMENT_AMOUNT;
            lastSpeedIncreaseTime = currentTime;
        }

        if (!isStunned) {
            updateLaneMarks(deltaTime);
        }

        updateItems(deltaTime);
        updateHUD();

        gameFrame = requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
