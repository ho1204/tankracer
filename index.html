<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª¨ë˜ 2D íƒ±í¬ ë ˆì´ì„œ</title>
    <!-- Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* ë¸Œë£¨ë“œì›Œ ëŠë‚Œì˜ ì–´ë‘ìš´ ìš°ì£¼/ê¸°ì§€ ë°°ê²½ */
            background:
                radial-gradient(circle at 20% 0%, #303843 0, transparent 55%),
                radial-gradient(circle at 80% 0%, #222b33 0, transparent 55%),
                radial-gradient(circle at 50% 120%, #050910 0, #020308 60%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            min-height: 100vh;
            /* ë‘êº¼ìš´ í…Œë€ì‹ UI í”„ë ˆì„ */
            box-shadow:
                0 0 0 2px #0c1016,
                0 0 0 4px #1b2836,
                0 0 30px rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            overflow: hidden;
            background: linear-gradient(to bottom, #05070b, #05070b 40%, #080c12 100%);
            display: flex;
            flex-direction: column;
            border: 1px solid #0e1b29;
        }

        #gameCanvas {
            position: relative;
            width: 100%;
            flex-grow: 1;
            /* ë¸Œë£¨ë“œì›Œ ì§€ìƒ/ë©”íƒˆ í”Œë«í¼ ëŠë‚Œ */
            background-color: #10141c;
            background-image:
                linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0, transparent 40%),
                linear-gradient(#191f2a 1px, transparent 0),
                linear-gradient(90deg, #191f2a 1px, transparent 0),
                radial-gradient(circle at 20% 20%, rgba(120, 130, 150, 0.3) 0, transparent 45%),
                radial-gradient(circle at 80% 35%, rgba(60, 70, 90, 0.3) 0, transparent 45%);
            background-size:
                100% 100%,
                3px 3px,
                3px 3px,
                120% 120%,
                120% 120%;
            box-shadow: inset 0 0 80px rgba(0, 0, 0, 0.9);
            touch-action: none;
            transform: perspective(700px) rotateX(4deg);
            transform-origin: bottom;
        }

        .lane-mark {
            position: absolute;
            /* í™œì£¼ë¡œ ìœ ë„ë“± ëŠë‚Œì˜ ì°¨ì„  */
            background: linear-gradient(to bottom,
                rgba(0, 255, 220, 0.1),
                rgba(0, 255, 220, 0.9)
            );
            width: 8px;
            height: 140px;
            opacity: 0.95;
            border-radius: 6px;
            box-shadow:
                0 0 6px rgba(0, 255, 255, 0.9),
                0 0 18px rgba(0, 180, 255, 0.8);
            z-index: 10;
        }

        /* ============== íƒ±í¬ (í”Œë ˆì´ì–´) ============== */
        #player {
            position: absolute;
            width: 75px;
            height: 75px;
            bottom: 70px; /* ê¸°ì¡´ 100pxì—ì„œ ë‚´ë ¤ì„œ í™”ë©´ì´ ë” ê¸¸ê²Œ ë³´ì´ë„ë¡ */
            transition: left 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 50;
            /* ì‚´ì§ ê·¸ë¦¼ì */
            filter: drop-shadow(0 6px 4px rgba(0, 0, 0, 0.9));
            /* íƒ±í¬ ì „ì²´ë¥¼ 7% ì¶•ì†Œ */
            transform: scale(0.93);
            transform-origin: center bottom;
        }

        /* íƒ±í¬ ë³¸ì²´ (ì§™ì€ íšŒìƒ‰) - í”Œë ˆì´ì–´ ì •ì¤‘ì•™ ê¸°ì¤€ ì¬ì¡°ì • */
        .tank-body {
            position: absolute;
            width: 55px;
            height: 70px;
            left: 10px;
            bottom: 10px;
            /* í…Œë€ ì‹œì¦ˆíƒ±í¬ ëŠë‚Œì˜ ì¥ê°‘ìƒ‰ */
            background: linear-gradient(to bottom, #7a868e 0%, #4c555e 45%, #343c45 100%);
            border: 2px solid #151b20;
            border-radius: 5px;
            box-shadow:
                inset 0 0 0 1px rgba(220, 230, 240, 0.08),
                0 3px 6px rgba(0, 0, 0, 0.9);
        }

        .tank-tread-left, .tank-tread-right {
            position: absolute;
            width: 10px;
            height: 100%;
            background: linear-gradient(to bottom, #15181c, #050608);
            border-radius: 3px;
            box-shadow:
                inset 0 -2px 0 rgba(255, 255, 255, 0.06),
                inset 0 0 8px rgba(0, 0, 0, 0.8);
        }
        .tank-tread-left { left: 0; }
        .tank-tread-right { right: 0; }

        .tank-turret {
            position: absolute;
            width: 46px;
            height: 32px;
            background: linear-gradient(145deg, #b4bcc4 0%, #7e8991 40%, #58616a 100%);
            border-radius: 4px;
            top: 7px;
            left: 50%;
            transform: translateX(-50%);
            border: 2px solid #20262c;
            box-shadow:
                inset 0 0 0 1px rgba(255, 255, 255, 0.08),
                0 2px 6px rgba(0, 0, 0, 0.9);
            z-index: 60;
        }

        .tank-barrel {
            position: absolute;
            width: 14px;
            height: 38px;
            background: linear-gradient(to right, #868f97 0%, #b4bdc5 45%, #757f87 100%);
            border-radius: 3px 3px 0 0;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow:
                inset 0 0 4px rgba(0, 0, 0, 0.6),
                0 -2px 4px rgba(0, 0, 0, 0.9);
            z-index: 55;
        }

        .shield-effect {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 94px;
            height: 94px;
            border-radius: 12px;
            /* ë¸Œë£¨ë“œì›Œ ì‰´ë“œ ê°™ì€ ì²­ë¡ ë³´í˜¸ë§‰ */
            background: radial-gradient(circle at 30% 0%, rgba(0, 255, 255, 0.6), transparent 55%),
                        radial-gradient(circle at 70% 100%, rgba(0, 180, 255, 0.5), transparent 55%);
            border: 2px solid rgba(0, 255, 255, 0.8);
            box-shadow:
                0 0 18px rgba(0, 255, 255, 0.9),
                0 0 40px rgba(0, 120, 255, 0.85);
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 45;
        }

        .stunned {
            animation: flash 0.1s infinite alternate;
        }
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }

        .game-element {
            position: absolute;
            width: 55px;
            height: 55px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e8f3ff;
            font-size: 22px;
            font-weight: 700;
            border-radius: 6px;
            z-index: 40;
            border: 2px solid;
            transition: transform 0.05s, box-shadow 0.1s;
            background-color: rgba(5, 10, 18, 0.9);
            box-shadow:
                0 2px 6px rgba(0, 0, 0, 0.9),
                inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        @keyframes wiggle {
            0%, 100% { transform: translateX(0) rotate(5deg); }
            50% { transform: translateX(3px) rotate(5deg); }
        }

        .bomb {
            border-color: #ff4b4b;
            border-radius: 50%;
            font-size: 26px;
            color: #ff6b6b;
            box-shadow:
                0 0 10px rgba(255, 77, 77, 0.9),
                inset 0 0 8px rgba(0, 0, 0, 0.9);
        }
        .gift {
            border-color: #e0a96b;
            border-radius: 4px;
            transform: rotate(2deg);
            animation: wiggle 0.6s ease-in-out infinite alternate;
            color: #f0c27b;
            box-shadow:
                0 0 8px rgba(240, 194, 123, 0.8),
                inset 0 0 4px rgba(0, 0, 0, 0.8);
        }
        .boost {
            border-color: #31a9ff;
            border-radius: 50%;
            font-size: 18px;
            color: #7fd6ff;
            text-shadow: 0 0 6px rgba(0, 200, 255, 0.9);
            box-shadow:
                0 0 12px rgba(0, 180, 255, 0.9),
                inset 0 0 6px rgba(0, 0, 0, 0.8);
        }
        .shield {
            border-color: #85f0ff;
            border-radius: 50%;
            font-size: 24px;
            color: #aaf7ff;
            text-shadow: 0 0 6px rgba(150, 230, 255, 0.9);
            box-shadow:
                0 0 14px rgba(120, 220, 255, 0.9),
                inset 0 0 6px rgba(0, 0, 0, 0.8);
        }
        .slow {
            border-color: #35d19c;
            border-radius: 50%;
            font-size: 16px;
            color: #9af7d1;
            letter-spacing: 1px;
            text-transform: uppercase;
            box-shadow:
                0 0 10px rgba(0, 255, 180, 0.9),
                inset 0 0 6px rgba(0, 0, 0, 0.8);
        }

        .hud-top-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 8px 10px;
            pointer-events: none;
            z-index: 90;
        }

        .hud-item {
            padding: 5px 8px;
            border-radius: 3px;
            background: linear-gradient(to bottom, #050910, #050910 50%, #060c15 100%);
            color: #9fd6ff;
            font-weight: 600;
            box-shadow:
                0 0 0 1px #0b1926,
                inset 0 0 0 1px rgba(255, 255, 255, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.8);
            margin: 0 3px;
            min-width: 70px;
            text-align: center;
            font-size: 11px;
            line-height: 1.2;
        }

        .hud-value {
            font-size: 15px;
            font-weight: 900;
            color: #e5ff9a;
            text-shadow:
                0 0 4px rgba(180, 255, 120, 0.7),
                0 0 10px rgba(120, 255, 80, 0.6);
            display: block;
        }

        .indicator-overlay {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 90;
        }

        .indicator {
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 10px;
            background: radial-gradient(circle at 50% 0%, rgba(0, 0, 0, 0.2), transparent 70%),
                        rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(2px);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
        }

        .overlay-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            pointer-events: none;
            z-index: 70;
        }

        .overlay-button {
            width: 100px;
            height: 70px;
            background: radial-gradient(circle at 20% 0%, rgba(0, 255, 255, 0.2), transparent 60%),
                        rgba(5, 10, 18, 0.9);
            border: 1px solid #1d3a4f;
            color: #aef3ff;
            font-size: 2.4rem;
            font-weight: 900;
            text-shadow:
                0 0 6px rgba(0, 255, 255, 0.9),
                0 0 12px rgba(0, 180, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.05s, background 0.1s, box-shadow 0.1s;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.9);
        }

        .overlay-button:active {
            transform: scale(0.95);
            background: radial-gradient(circle at 50% 100%, rgba(0, 255, 180, 0.4), transparent 70%),
                        rgba(8, 16, 26, 1);
            box-shadow:
                0 0 10px rgba(0, 255, 200, 0.9),
                0 0 20px rgba(0, 180, 255, 0.9);
        }

        .message-box {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .message-content {
            background: radial-gradient(circle at 0 0, #1b2836 0, #050910 55%, #020308 100%);
            padding: 26px;
            border-radius: 10px;
            text-align: center;
            box-shadow:
                0 0 0 1px #0b1926,
                inset 0 0 0 1px rgba(255, 255, 255, 0.05),
                0 12px 30px rgba(0, 0, 0, 0.95);
            color: #dfefff;
            border: 1px solid #1f3b55;
        }
    @media (max-width: 480px) {
        /* ëª¨ë°”ì¼ì—ì„œ ì–‘ì˜†ìœ¼ë¡œ ë„“ì–´ ë³´ì´ëŠ” ëŠë‚Œì„ ì¤„ì´ê³  ì„¸ë¡œë¡œ ë” ê¸¸ê²Œ ë³´ì´ë„ë¡ ì¡°ì • */
        .game-container {
            width: 90%;
            max-width: 380px;
        }
        #gameCanvas {
            transform: perspective(900px) rotateX(2deg);
            transform-origin: bottom;
        }
    }
    </style>
</head>
<body>

<div class="game-container">
    <div id="gameCanvas">
        <!-- HUD -->
        <div id="hudOverlay" class="hud-top-overlay">
            <div class="flex-1 text-left">
                <div class="hud-item inline-block">
                    ì ìˆ˜: <span id="scoreDisplay" class="hud-value">0</span>
                </div>
                <div class="hud-item inline-block">
                    ê±°ë¦¬: <span id="distanceDisplay" class="hud-value text-green-400">0 m</span>
                </div>
                <div class="hud-item inline-block">
                    ì‹œê°„: <span id="timeDisplay" class="hud-value text-blue-400">0.0 s</span>
                </div>
            </div>
            <div class="flex-1 text-right">
                <div class="hud-item inline-block">
                    ì†ë„: <span id="speedDisplay" class="hud-value">2.0 m/s</span>
                </div>
                <div class="hud-item inline-block">
                    í­íƒ„: <span id="bombHitDisplay" class="hud-value text-red-400">0 / 3</span>
                </div>
            </div>
        </div>

        <!-- ì¸ë””ì¼€ì´í„° -->
        <div class="indicator-overlay">
            <span id="boostIndicator" class="indicator text-blue-300 hidden">
                <i class="fas fa-bolt"></i> X2 í™œì„±í™” (<span id="boostTimer">0.0</span>s)
            </span>
            <span id="shieldIndicator" class="indicator text-purple-300 hidden">
                <i class="fas fa-shield-alt"></i> ë°©íŒ¨: 1íšŒ
            </span>
        </div>

        <!-- í”Œë ˆì´ì–´ íƒ±í¬ -->
        <div id="player">
            <div id="shieldEffect" class="shield-effect hidden"></div>
            <div class="tank-tread-left"></div>
            <div class="tank-tread-right"></div>
            <div class="tank-body"></div>
            <div class="tank-turret"></div>
            <div class="tank-barrel"></div>
        </div>

        <!-- ì‹œì‘/ê²Œì„ì˜¤ë²„ ë©”ì‹œì§€ -->
        <div id="messageBox" class="message-box" style="display: flex;">
            <div class="message-content">
                <h2 class="text-3xl font-bold mb-4 text-white">íƒ±í¬ ë¡œë“œ ë ˆì´ì„œ (SC-T)</h2>
                <p class="mb-6 text-gray-300">í™”ë©´ ìŠ¤ì™€ì´í”„, ì°¨ì„  í„°ì¹˜, í•˜ë‹¨ ë²„íŠ¼ìœ¼ë¡œ ì°¨ì„ ì„ ë³€ê²½í•˜ì„¸ìš”!</p>
                <p class="mb-8 text-sm text-gray-400">í­íƒ„ 3íšŒ ì¶©ëŒ ì‹œ ê²Œì„ ì˜¤ë²„</p>
                <button id="startButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 rounded-xl transition duration-150 shadow-lg">
                    <i class="fas fa-play"></i> ê²Œì„ ì‹œì‘ (2m/s)
                </button>
            </div>
        </div>

        <!-- ì¡°ì‘ ë²„íŠ¼ -->
        <div class="overlay-controls">
            <button id="leftButton" class="overlay-button">
                <i class="fas fa-arrow-left"></i>
            </button>
            <button id="rightButton" class="overlay-button">
                <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>
</div>

<script>
    // ============== ìƒìˆ˜ ë° ì´ˆê¸° ì„¤ì • ==============
    const gameCanvas = document.getElementById('gameCanvas');
    const player = document.getElementById('player');
    const shieldEffect = document.getElementById('shieldEffect');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const distanceDisplay = document.getElementById('distanceDisplay');
    const speedDisplay = document.getElementById('speedDisplay');
    const bombHitDisplay = document.getElementById('bombHitDisplay');
    const messageBox = document.getElementById('messageBox');
    const startButton = document.getElementById('startButton');
    const boostIndicator = document.getElementById('boostIndicator');
    const boostTimer = document.getElementById('boostTimer');
    const shieldIndicator = document.getElementById('shieldIndicator');
    const leftButton = document.getElementById('leftButton');
    const rightButton = document.getElementById('rightButton');
    const timeDisplay = document.getElementById('timeDisplay');

    const LANE_WIDTH = 100;
    const INITIAL_SPEED = 2.0;
    const SPEED_INCREMENT_TIME = 8000;
    const SPEED_INCREMENT_AMOUNT = 0.5;

    const LANE_MARK_HEIGHT = 120;  // ì°¨ì„  ê¸¸ì´ ì¦ê°€
    const LANE_MARK_GAP = 60;    // ê°„ê²©ì„ ì¤„ì—¬ ê±°ì˜ ì´ì–´ì§„ ëŠë‚Œ
    const LANE_MARK_CYCLE = LANE_MARK_HEIGHT + LANE_MARK_GAP;

    // í­íƒ„/ì•„ì´í…œ ê°„ê²©(5% ì¦ê°€)
    const ITEM_MIN_GAP_DISTANCE = 157.5;

    const BOOST_DURATION = 4000;
    const BOMB_STUN_DURATION = 300;
    const BOMB_MAX_HITS = 3;

    const RARE_ITEM_COOLDOWN = 10000;
    const SLOW_ITEM_COOLDOWN = 30000; // 30ì´ˆë§ˆë‹¤ ì†ë„ ê°ì†Œ ì•„ì´í…œ

    const SWIPE_THRESHOLD = 50;

    // ============== ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ==============
    let isPlaying = false;
    let score = 0;
    let distance = 0;       // m
    let elapsedTime = 0;    // s
    let speed = INITIAL_SPEED;
    let bombHits = 0;
    let shieldCount = 0;
    let isStunned = false;

    // 1më‹¹ ì ìˆ˜ ì¦ê°€ ê¸°ì¤€
    let lastScoreDistance = 0;

    let touchStartX = 0;
    let lastTime = 0;

    let items = [];
    let laneMarks = [];

    let nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE * 1.5;

    let lastSpeedIncreaseTime = 0;
    let lastBoostTime = 0;
    let lastShieldTime = 0;
    let lastSlowTime = 0;

    const HIGH_SCORE_KEY = 'tankRacerHighScore';
    let bestScore = 0;
    try {
        const stored = localStorage.getItem(HIGH_SCORE_KEY);
        if (stored !== null) {
            const parsed = parseInt(stored, 10);
            if (!isNaN(parsed)) bestScore = parsed;
        }
    } catch (e) {
        bestScore = 0;
    }

    let gameFrame = null;

    let canvasWidth = 0;
    let canvasHeight = 0;
    let laneCenters = [0, 0, 0];
    let currentLane = 1; // ê°€ìš´ë°

    const playerWidth = 70;  // íƒ±í¬ 7% ì¶•ì†Œ ë°˜ì˜(ëŒ€ëµ 75 * 0.93)
    const playerHeight = 70;  // íƒ±í¬ 7% ì¶•ì†Œ ë°˜ì˜
    const itemSize = 55;
    const PLAYER_BOTTOM_OFFSET = 70;  // íƒ±í¬ë¥¼ ë” ì•„ë˜ì— ë°°ì¹˜í•´ í™”ë©´ì´ ë” ê¸¸ê²Œ ë³´ì´ë„ë¡
    const DRAW_FACTOR = 150;

    // ============== ì´ˆê¸°í™” ë° ë¦¬ì‚¬ì´ì¦ˆ ==============
    function setupCanvas() {
        canvasWidth = gameCanvas.clientWidth;
        canvasHeight = gameCanvas.clientHeight;

        laneCenters[0] = canvasWidth / 2 - LANE_WIDTH;
        laneCenters[1] = canvasWidth / 2;
        laneCenters[2] = canvasWidth / 2 + LANE_WIDTH;

        resetPlayerPosition();
    }

    function resetPlayerPosition() {
        player.style.left = `${laneCenters[currentLane] - playerWidth / 2}px`;
        player.style.bottom = `${PLAYER_BOTTOM_OFFSET}px`;
    }

    // ============== ê²Œì„ ìƒíƒœ ê´€ë¦¬ ==============
    function startGame() {
        if (isPlaying) return;

        score = 0;
        distance = 0;
        elapsedTime = 0;
        lastScoreDistance = 0;
        speed = INITIAL_SPEED;
        bombHits = 0;
        shieldCount = 0;
        isStunned = false;
        currentLane = 1;

        // ê¸°ì¡´ ìš”ì†Œ ì œê±°
        items.forEach(item => item.element.remove());
        items = [];
        laneMarks.forEach(mark => mark.element.remove());
        laneMarks = [];

        const now = performance.now();
        nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE * 1.5;

        lastTime = now;
        lastSpeedIncreaseTime = now;
        lastBoostTime = now - RARE_ITEM_COOLDOWN;   // ì‹œì‘ë¶€í„° ë¶€ìŠ¤íŠ¸/ë°©íŒ¨ ì¶œí˜„ ê°€ëŠ¥
        lastShieldTime = now - RARE_ITEM_COOLDOWN;
        lastSlowTime = now;                          // ì²« ì†ë„ ê°ì†Œ ì•„ì´í…œì€ 30ì´ˆ í›„ì¯¤

        messageBox.style.display = 'none';
        player.classList.remove('stunned');
        updateShieldVisual();
        updateHUD();
        resetPlayerPosition();

        isPlaying = true;
        gameFrame = requestAnimationFrame(gameLoop);
    }

    function endGame() {
        if (!isPlaying) return;
        isPlaying = false;
        if (gameFrame) cancelAnimationFrame(gameFrame);

        let isNewRecord = false;
        if (score > bestScore) {
            isNewRecord = true;
            bestScore = score;
            try {
                localStorage.setItem(HIGH_SCORE_KEY, String(bestScore));
            } catch (e) {
                // localStorage ì‚¬ìš© ë¶ˆê°€ í™˜ê²½ì€ ë¬´ì‹œ
            }
        }

        messageBox.style.display = 'flex';

        const titleEl = document.querySelector('.message-content h2');
        if (isNewRecord) {
            titleEl.textContent = '!!ìµœê³  ì ìˆ˜!!';
        } else {
            titleEl.textContent = 'ğŸ’¥ ê²Œì„ ì˜¤ë²„! ğŸ’¥';
        }

        document.querySelector('.message-content p').innerHTML =
            `ìµœì¢… ì ìˆ˜: <span class="font-bold text-2xl text-yellow-500">${score} ì </span><br>` +
            `ìµœê³  ì ìˆ˜: <span class="font-bold text-2xl text-yellow-500">${bestScore} ì </span><br>` +
            `ì£¼í–‰ ê±°ë¦¬: <span class="font-bold text-2xl text-green-500">${distance.toFixed(0)} m</span><br>` +
            `ì§„í–‰ ì‹œê°„: <span class="font-bold text-2xl text-blue-400">${elapsedTime.toFixed(1)} s</span>`;
        startButton.innerHTML = '<i class="fas fa-redo"></i> ë‹¤ì‹œ ì‹œì‘';
    }

    function handleStun() {
        if (isStunned) return;
        isStunned = true;
        player.classList.add('stunned');
        setTimeout(() => {
            isStunned = false;
            player.classList.remove('stunned');
        }, BOMB_STUN_DURATION);
    }

    function updateShieldVisual() {
        shieldEffect.classList.toggle('hidden', shieldCount <= 0);
    }

    // ============== ì´ë™/ì…ë ¥ ì²˜ë¦¬ ==============
    function moveTank(direction) {
        if (!isPlaying || isStunned) return;
        const newLane = currentLane + direction;
        if (newLane >= 0 && newLane < 3) {
            currentLane = newLane;
            player.style.left = `${laneCenters[currentLane] - playerWidth / 2}px`;
        }
    }

    startButton.addEventListener('click', startGame);
    leftButton.addEventListener('click', () => moveTank(-1));
    rightButton.addEventListener('click', () => moveTank(1));

    document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
            moveTank(-1);
        } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
            moveTank(1);
        }
    });

    function handleStart(e) {
        if (!isPlaying) return;
        if (e.target.closest('.overlay-button')) return;
        e.preventDefault();
        touchStartX = e.touches ? e.touches[0].clientX : e.clientX;
    }

    function handleEnd(e) {
        if (!isPlaying) return;
        if (e.target.closest('.overlay-button')) return;

        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const deltaX = clientX - touchStartX;

        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
            // ìŠ¤ì™€ì´í”„
            if (deltaX > 0) moveTank(1);
            else moveTank(-1);
        } else {
            // ì°¨ì„  í„°ì¹˜: í™”ë©´ ì™¼ìª½ 1/3 â†’ ì™¼ìª½, ì˜¤ë¥¸ìª½ 1/3 â†’ ì˜¤ë¥¸ìª½
            const rect = gameCanvas.getBoundingClientRect();
            const xRelative = clientX - rect.left;

            if (xRelative < canvasWidth / 3) {
                moveTank(-1);
            } else if (xRelative > (canvasWidth * 2) / 3) {
                moveTank(1);
            }
        }
    }

    gameCanvas.addEventListener('touchstart', handleStart);
    gameCanvas.addEventListener('touchend', handleEnd);
    gameCanvas.addEventListener('mousedown', handleStart);
    gameCanvas.addEventListener('mouseup', handleEnd);

    window.addEventListener('resize', setupCanvas);
    window.addEventListener('load', setupCanvas);

    // ============== ì°¨ì„  ë§ˆí¬ ==============
    function spawnLaneMarks(yPosition) {
        const markWidth = 10;
        const boundary1X = laneCenters[1] - LANE_WIDTH / 2 - markWidth / 2;
        const boundary2X = laneCenters[1] + LANE_WIDTH / 2 - markWidth / 2;

        [boundary1X, boundary2X].forEach(xPos => {
            const mark = document.createElement('div');
            mark.className = 'lane-mark';
            mark.style.left = `${xPos}px`;
            mark.style.top = `${yPosition}px`;
            gameCanvas.appendChild(mark);
            laneMarks.push({ element: mark, y: yPosition });
        });
    }

    function updateLaneMarks(deltaTime) {
        const moveDistance = speed * deltaTime * DRAW_FACTOR;

        for (let i = laneMarks.length - 1; i >= 0; i--) {
            const mark = laneMarks[i];
            mark.y += moveDistance;
            mark.element.style.top = `${mark.y}px`;
            if (mark.y > canvasHeight) {
                mark.element.remove();
                laneMarks.splice(i, 1);
            }
        }

        const topMark = laneMarks.length > 0
            ? laneMarks.reduce((a, b) => (a.y < b.y ? a : b))
            : null;

        if (!topMark || topMark.y >= -LANE_MARK_CYCLE) {
            const newY = topMark ? topMark.y - LANE_MARK_CYCLE : -LANE_MARK_HEIGHT;
            spawnLaneMarks(newY);
        }
    }

    // ============== ì•„ì´í…œ ìŠ¤í°/ì—…ë°ì´íŠ¸ ==============
    function spawnItem() {
        const laneIndex = Math.floor(Math.random() * 3);
        const now = performance.now();

        const isBoostReady = now - lastBoostTime >= RARE_ITEM_COOLDOWN;
        const isShieldReady = now - lastShieldTime >= RARE_ITEM_COOLDOWN;
        const isSlowReady = now - lastSlowTime >= SLOW_ITEM_COOLDOWN;

        const itemPool = ['bomb', 'gift'];
        if (isBoostReady) itemPool.push('boost');
        if (isShieldReady) itemPool.push('shield');

        let itemType;
        const rand = Math.random();

        if (isSlowReady) {
            // 30ì´ˆë§ˆë‹¤ í•œ ë²ˆì€ ì†ë„ ê°ì†Œ ì•„ì´í…œ
            itemType = 'slow';
            lastSlowTime = now;
        } else {
            // í­íƒ„ 45%, ì„ ë¬¼ 45%, ë ˆì–´(ë¶€ìŠ¤íŠ¸/ë°©íŒ¨) 10%
            if (rand < 0.45) {
                itemType = 'bomb';
            } else if (rand < 0.90) {
                itemType = 'gift';
            } else {
                const rareItems = itemPool.filter(i => i === 'boost' || i === 'shield');
                if (rareItems.length > 0) {
                    itemType = rareItems[Math.floor(Math.random() * rareItems.length)];
                } else {
                    itemType = Math.random() < 0.5 ? 'bomb' : 'gift';
                }
            }
        }

        // ë ˆì–´ ì•„ì´í…œ ì¿¨ë‹¤ìš´ ê°±ì‹ 
        if (itemType === 'boost' && isBoostReady) {
            lastBoostTime = now;
        } else if (itemType === 'shield' && isShieldReady) {
            lastShieldTime = now;
        }

        const element = document.createElement('div');
        element.className = 'game-element ' + itemType;
        element.style.top = `${-itemSize}px`;
        element.style.left = `${laneCenters[laneIndex] - itemSize / 2}px`;
        element.dataset.type = itemType;

        switch (itemType) {
            case 'bomb':
                element.innerHTML = '<i class="fas fa-bomb"></i>';
                break;
            case 'gift':
                element.innerHTML = '<i class="fas fa-gift"></i>';
                break;
            case 'boost':
                element.innerHTML = 'X2';
                break;
            case 'shield':
                element.innerHTML = '<i class="fas fa-shield-alt"></i>';
                break;
            case 'slow':
                element.innerHTML = 'slow';
                break;
        }

        gameCanvas.appendChild(element);
        items.push({ element, y: -itemSize, laneIndex });
    }

    function updateItems(deltaTime) {
        const now = performance.now();
        const effectiveSpeed = isStunned ? 0 : speed;
        const moveDistance = effectiveSpeed * deltaTime * DRAW_FACTOR;

        nextItemSpawnDistance -= moveDistance;
        if (nextItemSpawnDistance <= 0) {
            spawnItem();
            nextItemSpawnDistance = ITEM_MIN_GAP_DISTANCE + Math.random() * 100;
        }

        const playerX = parseFloat(player.style.left) || (laneCenters[currentLane] - playerWidth / 2);
        const playerYTop = canvasHeight - playerHeight - PLAYER_BOTTOM_OFFSET;
        const playerYBottom = canvasHeight - PLAYER_BOTTOM_OFFSET;

        for (let i = items.length - 1; i >= 0; i--) {
            const item = items[i];
            item.y += moveDistance;
            item.element.style.top = `${item.y}px`;

            const itemX = parseFloat(item.element.style.left);

            const isColliding =
                item.y + itemSize > playerYTop &&
                item.y < playerYBottom &&
                itemX < playerX + playerWidth &&
                itemX + itemSize > playerX;

            if (isColliding) {
                handleCollision(item, now);
                item.element.remove();
                items.splice(i, 1);
            } else if (item.y > canvasHeight) {
                item.element.remove();
                items.splice(i, 1);
            }
        }
    }

    function handleCollision(item, now) {
        const itemType = item.element.dataset.type;
        const isBoostActive = now < lastBoostTime + BOOST_DURATION;

        switch (itemType) {
            case 'bomb':
                if (shieldCount > 0) {
                    shieldCount--;
                    updateShieldVisual();
                } else {
                    bombHits++;
                    handleStun();
                    if (bombHits >= BOMB_MAX_HITS) {
                        endGame();
                        return;
                    }
                }
                break;
            case 'gift':
                score += isBoostActive ? 20 : 10;
                break;
            case 'boost':
                lastBoostTime = now;
                break;
            case 'shield':
                shieldCount = 1;
                updateShieldVisual();
                break;
            case 'slow':
                speed = Math.max(0.5, speed - 0.3);
                break;
        }

        updateHUD();
    }

    // ============== HUD ==============
    function updateHUD() {
        const now = performance.now();
        const boostEndTime = lastBoostTime + BOOST_DURATION;
        const isBoostActive = now < boostEndTime;

        scoreDisplay.textContent = score;
        distanceDisplay.textContent = `${distance.toFixed(0)} m`;
        timeDisplay.textContent = `${elapsedTime.toFixed(1)} s`;
        speedDisplay.textContent = `${speed.toFixed(1)} m/s`;
        bombHitDisplay.textContent = `${bombHits} / ${BOMB_MAX_HITS}`;

        boostIndicator.classList.toggle('hidden', !isBoostActive);
        if (isBoostActive) {
            const remainingSeconds = Math.max(0, (boostEndTime - now) / 1000);
            boostTimer.textContent = remainingSeconds.toFixed(1);
        }

        shieldIndicator.classList.toggle('hidden', shieldCount <= 0);
    }

    // ============== ë©”ì¸ ë£¨í”„ ==============
    function gameLoop(currentTime) {
        if (!isPlaying) return;

        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        elapsedTime += deltaTime;

        const effectiveSpeed = isStunned ? 0 : speed;
        distance += effectiveSpeed * deltaTime;

        // 1m ì§„í–‰ ì‹œ 1ì ì”© ì¦ê°€
        const distanceInt = Math.floor(distance);
        if (distanceInt > lastScoreDistance) {
            score += distanceInt - lastScoreDistance;
            lastScoreDistance = distanceInt;
        }

        // ì¼ì • ì‹œê°„ë§ˆë‹¤ ì†ë„ ì¦ê°€
        if (currentTime - lastSpeedIncreaseTime >= SPEED_INCREMENT_TIME) {
            speed += SPEED_INCREMENT_AMOUNT;
            lastSpeedIncreaseTime = currentTime;
        }

        if (!isStunned) {
            updateLaneMarks(deltaTime);
        }

        updateItems(deltaTime);
        updateHUD();

        gameFrame = requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
